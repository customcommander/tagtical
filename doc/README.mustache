![](https://github.com/customcommander/tagtical/workflows/release/badge.svg?branch=master)
![](https://github.com/customcommander/tagtical/workflows/continuous%20integration/badge.svg?branch=master)


# tagtical

```
npm i @customcommander/tagtical
```

[![npm version](https://badge.fury.io/js/%40customcommander%2Ftagtical.svg)](https://www.npmjs.com/package/@customcommander/tagtical)

## Why?

Say you're given a number _n_ and depending on its value you return either _"There is 1 fox"_ or _"There are 10 foxes"_.

Here's a typical implementation:

```javascript
`There ${n === 1 ? 'is' : 'are'} ${n} ${n === 1 ? 'fox' : 'foxes'}`
```

Simple enough yet already difficult to parse and the intent is obfuscated.

Can we do better? How about this?

```javascript
import {pluralize} from '@customcommander/tagtical';

let n = 1;
pluralize`There is/are ${n} fox(es)`;
//=> "There is 1 fox"

n = 10;
pluralize`There is/are ${n} fox(es)`;
//=> "There are 10 foxes"
```

If you find yourself nodding along, then _maybe_ `tagtical` is for you.

## Design philosophy

If an interpolated value is not of the expected type, it is returned as is. This means that you can always apply a tagged template without worrying about types:

```javascript
import {lower} from '@customcommander/tagtical';

const num = 1;
const food = 'BURRITO';

lower`I only had ${num} ${food}!`;
//=> "I only had 1 burrito!"

```

## Documentation

{{> api}}
